# Artaic MTO Probability Model 
# Based on Pricing and lead time decisions for make-to-order firms with contingent orders
# By Fred F. Easton, Douglas R. Moodie

# input data {(current orders:array),(Wj estimated work content [days]:Calculated Float), (dj days unti job due: float),
# (k direct cost per unit of work content: float)}
from numpy import array
from math import exp
from itertools import product
n = 3                               # Number of machines

Schedule = {
    0:{1:1, 2:1, 3:1, 4:0, 5:0},
    1:{1:1, 2:1, 3:1, 4:0, 5:0},
    2:{1:1, 2:1, 3:1, 4:0}
}                                   # Dictionary of jobs where key = machine jobs , value = machine number, inside value is dict with key = job name and value = 1 or 0 (1 if booked, 0 otherwise)

Machine_info = {                    # Key corresponds to row in the schedule, value is ordered as {Machine name, tile size handeled (1 = less than 1 inch, 2 = 1 inch, machine speed proportional to Wack-A-Tile)
    0:['Arty', 1, 1.5],
    1:['Arnold', 1, 1.25],
    2:['Wack-A-Tile', 2, 1]
}

Pj = [
    [1, 1, 1, 0.3, 0.9],
    [1, 1, 1, 0.3, 0.9],
    [1, 1, 1, 0.3]
]                                   # Probability order is accepted at cost Cj and days until job due dj

Wj = [                              
    [4, 15, 10, 25, 5],
    [4, 15, 10, 25, 5],
    [4, 3, 2, 5] 
]                                   # Currently in hours

# Finds machine with soonest expected finish time and places new job on it 
def Job_Placement(machines, new_job, tile_size, schedule_status, probability, work_content):
    Et = []                                                 # Expected finish time list
    row_counter = 0
    if tile_size < 1:                                       # If tile type is smaller than 1 job can be placed on any machine
        for machine in machines: 
            expected_time = 0
            column_counter = 0
            for job in machines[machine]:
                if machines[machine][job] == 1:
                    expected_time += Wj[row_counter][column_counter]
                    column_counter += 1
                else:
                    expected_time += Wj[row_counter][column_counter] * Pj[row_counter][column_counter]
                    column_counter += 1
            adjusted_work_content = work_content * Machine_info[row_counter][2]     # Adjusts work content based on speed of machine
            expected_time += adjusted_work_content                                  # Adds time it would take each machine to complete new job to expected_time
            Et.append(expected_time)                                                # Appends each machine expected time to Et list
            row_counter += 1                                                        # Moves to next row in matrix
        index = Et.index(min(Et))                                                   # Gets index of minimum value so we know what machine to add an incoming job to
    else:                                                                           # If tile size is 1 only the wack-a-tile can handle the job
        index = 2                                                                   # Places new job on 'Wack-A-Tile' since this is the only machine handling that tile size
    machines[index][new_job] = schedule_status                                      # Places new job on machine with soonest expected finish (identified by the index)        
    Pj[index].append(probability)                                                   # Adds probability of being accepted to Pj matrix for selected machine
    adjusted_work_content = int(round(work_content * Machine_info[index][2],0))     # Adjusts work content based on speed of machine and rounds to integer value
    Wj[index].append(adjusted_work_content)                                         # Adds work content of new job to Wj matrix for selected machine
    print (machines[index])
    print (Wj[index])
    realizations(Schedule, index)                                                   # Calls realization function to be done on selected machine

# Function to iterate all binary job backlogs and adds them to realization log, also generates all possible schedules
def realizations(job, machine_number):
    bk = []                     # The kth realization of the backlog, where bk is an ordered binary vector of length N where it is the set of b(k)j
    all_realizations = []       # List of all possible realization lists 
    sk = []                     # Schedule for realization k
    daily_schedule = []         # List of all possible realization schedules
    realization_K = 0           # Counter of each realization number
    unconfirmed_jobs = 0        # Initializes unconfirmed jobs counter
    potential_work_content = 0  # Total work content if all new jobs were accepted
    current_work_content = 0    # Total work content of all current accepted jobs
    Prob_bk = []                # Probability each backlog is realized
    index3 = 0
    
    for j in job[machine_number]:                               # Finds number of unconfirmed jobs (number of dictionary (jobs) entries with value of 0)
        if job[machine_number][j] == 0:
            unconfirmed_jobs += 1
            potential_work_content += Wj[machine_number][index3] 
            index3 += 1
        else:
            current_work_content += Wj[machine_number][index3]   
            index3 += 1

    length = len(job[machine_number]) - unconfirmed_jobs       # Finds number of confirmed jobs (number of dictionary (jobs) entries with value of 1)
    copy_length = length
    possible_backlogs = list(map(list, product([0, 1], repeat=unconfirmed_jobs))) # iterate all values of binary sequence based

    for i in possible_backlogs:                 # adds each possible binary backlog to the current jobs log and prints resulting list
        current_realization = i           
        index = 0
        index1 = 0
        digit = 0
        
        while copy_length > 0:
            bk.append(1)
            for work_content in range(Wj[machine_number][digit]):
                sk.append(digit + 1)
            digit += 1
            copy_length -= 1
        digit = length 
        
        if realization_K == 0:
            for zero in range(potential_work_content):
                sk.append(0)                    # appends zeros to end of current accepted job order. Appends amount = potential_work_content so maximum list length is found preventing "list assignment out of range" error
        
        for bj in current_realization:          # sets list entry after all confirmed orders a digit bj of our current backlog realization
            if realization_K == 0:
                bk.append(bj)
            elif realization_K > 0:
                bk[length + index] = bj         # length + index moves through each non-confirmed order to change its value to bj
                if bj == 1:
                    for work_content in range(Wj[machine_number][digit]):
                        sk[current_work_content + index1] = digit + 1
                        index1 += 1
                for entry, item in enumerate(sk):   # without this loop values from previous iterations of the list may show up incorrectly in schedule
                    if (item > digit + 1):
                        sk[entry] = 0
                digit += 1                      # if the loop isn't entered digit must be indexed so it displays as the following jobs number
                index += 1                     
        copy_bk = bk[:]                         # allows for the appending of bk to backlog so previous appends aren't changed to current append 
        copy_sk = sk[:]                         # allows for the appending of bsk to schedule so previous appends aren't changed to current append
        all_realizations.append(copy_bk)        # appends the realization list to have each possbile backlog
        daily_schedule.append(copy_sk)          # appends the daily schedule to have each possbile schedule
        realization_K += 1                      # moves to next realization realization
    
    for elm in all_realizations:
        print (elm)
    
    for elm1 in daily_schedule:
        print (elm1) 
    
    # Finds the probability of each k realized backlog (I have this written as its own function in another script, but the variables wouldnt pass right)
    index2 = 0
    for B in all_realizations:                              # looks at each list entry (which is also a list) in all_realizations
        counter2 = 0                                
        Prob_bk.append(1)                                 # Appends a 1 to the pobability of bk list so the P(Cj,dj)j can be multipled
        for bj in B:                                        # Looks at each list entry in B (so either a 1 or 0 value)
            if not Pj[machine_number][counter2] == 1:                       # If P(Cj,dj)j does not equal 1 (meaning a job hasn't been accepted yet)
                # formula 4 in paper
                if bj == 1:                                
                    Prob_bk[index2] *= Pj[machine_number][counter2]         # Multiply Prob_bk by P(Cj,dj)j since we are considering job as accepted (1) 
                else:
                    Prob_bk[index2] *= 1 - Pj[machine_number][counter2]     # Multiply Prob_bk by 1 - P(Cj,dj)j since we are consider job not yet accepted (0)
            counter2 += 1
        index2 += 1
    print(Prob_bk)
    Prob_Idle_Workcenter(Prob_bk, unconfirmed_jobs, daily_schedule, current_work_content, potential_work_content, machine_number)
    
# Probability workcenter will be idle during period t, or p(At = 0)
def Prob_Idle_Workcenter(P_Realized_BL, job, Shop_Schedule, CWC, PWC, machine_number):    # Pass in Prob_bk, unconfirmed_jobs, and Schedule
    counter3 = 0
    P_Idle_WC = [0] * len(Shop_Schedule[0])
    for entry in range(len(Shop_Schedule[0])):                  # For each entry in the potential schedule
        if Shop_Schedule[0][entry] > 0:                         # This only considers the first Schedule list entry because this contains all firm orders
            P_Idle_WC[counter3] = 0.0                           # probability shop is idle for firm orders is 0
            counter3 += 1                                       # Increments to next list item
        else:                                                   # If an entry = 0 it is unrealized
            for n in range(2 ** job):                           # Loops through all schedules to see if there are other unrealized values
                if Shop_Schedule[n][entry] == 0:                # Checks to see if there are other unrealized values
                    P_Idle_WC[counter3] += P_Realized_BL[n]     # Gives probability workcenter will be idle during time t, formula (5)
            counter3 += 1                                       # After all p(b(k)) summed for zero entries at that entry level, the counter is indexed
    print(P_Idle_WC)
    Available_shop_time_dist(P_Idle_WC, CWC, PWC, machine_number)

# Generates distribution for p(q,t) which is probability of exactly q units of available shop time through period d
# Where p(q,t) = [p(q - 1,t - 1) * p(At = 0) + p(q,t - 1)*(1 - p(At = 0))]
# Also generates the the CDF for the q_distribution for P(q<W,d)
def Available_shop_time_dist(At, CWC, PWC, machine_number):
    w = Wj[machine_number][len(Wj[machine_number])-1]
    t = CWC + 1
    q_dist = []
    CDF_q_dist =[1] * CWC                               # The CDF for the q_distribution for P(q<W,d) where each entry is for period T
    q = 0
    
    while q <= PWC:                                     # This while loop generates each base list for the function
        if q == 0:
            layer = [1] * CWC                           # The first layer there is 100% chance on no available shop time during the time of confirmed orders hence the value of 1 during this time
            q_dist.append(layer)
        else:
            layer = [x * 0 for x in range(1,CWC + q)]   # The remaining layers have zeros during the time period where there can be no available shop time (the number of zeros increases by 1 with each unit increase to q)
            q_dist.append(layer)
        q += 1
    
    limit = 1
    while t <= PWC + CWC:                               # This loop ends at the sum of PWC and CWC but it can actually continue infinitely with the same final values moved one unit q lower
        CDF = 0
        q = 0
        while q <= limit:
            # Formula 6
            prob = round(q_dist[q-1][t-2] * (At[t-1]) + q_dist[q][t-2] * (1 - At[t-1]),2)
            q_dist[q].append(prob)
            if q < w:
                # Formula 7 for each period T
                CDF += prob
            q += 1
        CDF_q_dist.append(CDF)
        limit += 1
        t += 1

    for elm in q_dist:
        print (elm)
    
    print (CDF_q_dist)
    
    Tardiness_dist (CDF_q_dist, machine_number, w, CWC, PWC, 0)
    
# Generates Tardiness Distribution with work content W and for each quoted lead time d
# Rows are expected Tardinesss begginning at 0
# columns are quoted lead times beginning at 1
def Tardiness_dist (CDF, machine_number, work_content, CWC, PWC, tardiness):
    # For T=0, p(T|W) = 1 - P(Q<W,d+T)
    w = work_content
    d = CWC + 1
    tardy_dist = []
    T = 0
    increment = 0
    CDF.append(0)
    max = 1
    
    # Generates initial shape of distribution (zeros)
    while T < CWC + PWC - 1:
        skip = 1
        layer = [x * 0 for x in range(1, d-increment)]                      # Adds beggining zeros prior to probabilities
        tardy_dist.append(layer)
        for probability in CDF:
            if probability != 1:                                            # Begins after firm jobs
                if T == 0:                                                  # If tardiness = 0, so the first row
                    if round(1-probability,2) == 0.0:
                        break
                    tardy_dist[T].append(round(1-probability,2))
                elif T > CWC and skip <= max:                               # The final PWC - 1 iterations pass 1 to PWC-1 iterations depending on their level of T
                    previous = probability
                    skip += 1
                    continue
                elif probability == CDF[len(CDF)-1]:                        # If last value in row looks directly at CDF because CDF excludes trailing 1s to save memory
                    value = CDF[len(CDF)-2]
                    if value == 0.0:
                        break
                    tardy_dist[T].append(value)
                else:
                    value = round((1-probability)-(1-previous),2)
                    if value == 0.0:
                        break
                    tardy_dist[T].append(value)
            previous = probability                                          # Stores the previous probability to be used in next iteration calculations
        if T > CWC:
            max += 1
        increment += 1
        T += 1
    
    
    
    for elm in tardy_dist:
        print (elm)

Job_Placement(Schedule, 'Holiday Inn', .75, 0, 0.9, 1)   

